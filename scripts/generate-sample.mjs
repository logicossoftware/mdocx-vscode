import { writeFile, mkdir } from 'node:fs/promises';
import { dirname, resolve } from 'node:path';
import { createBuilder, writeMdocxAsync } from 'ts-mdocx';

const repoRoot = resolve(process.cwd());
const outPath = resolve(repoRoot, 'samples', 'sample.mdocx');

const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="220" height="60" viewBox="0 0 220 60">
  <rect x="0" y="0" width="220" height="60" rx="10" fill="#2563eb"/>
  <text x="110" y="38" text-anchor="middle" font-family="Segoe UI, Arial" font-size="22" fill="#ffffff">MDOCX</text>
</svg>`;

const encoder = new TextEncoder();
const svgBytes = encoder.encode(svg);

const markdown = `# Sample MDOCX

This is a generated sample document.

![Logo](mdocx://media/logo)

A link to the same media by path: [assets/logo.svg](assets/logo.svg)

## Another file

Open the selector at the top to switch between embedded markdown files.`;

const doc = createBuilder()
  .title('Sample MDOCX')
  .description('Generated by scripts/generate-sample.mjs')
  .root('docs/index.md')
  .addMarkdown('docs/index.md', markdown)
  .addMarkdown('docs/notes.md', '# Notes\n\nThis is another embedded markdown file.')
  .addMedia('logo', svgBytes, { mimeType: 'image/svg+xml', path: 'assets/logo.svg' })
  .build();

await mkdir(dirname(outPath), { recursive: true });

// ZIP is the most interoperable and avoids optional codec initialization.
const bytes = await writeMdocxAsync(doc.markdown, doc.media, {
  metadata: doc.metadata,
  markdownCompression: 'zip',
  mediaCompression: 'zip'
});

await writeFile(outPath, bytes);

console.log(`Wrote ${outPath}`);
